/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/api/v1/accounts": {
    /** Returns a list of all account entity items on the network. */
    get: operations["listAccounts"];
  };
  "/api/v1/accounts/{idOrAliasOrEvmAddress}": {
    /** Return the account transactions and balance information given an account alias, an account id, or an evm address */
    get: operations["getAccountByIdOrAliasOrEvmAddress"];
  };
  "/api/v1/accounts/{idOrAliasOrEvmAddress}/nfts": {
    /**
     * Returns information for all non-fungible tokens for an account.
     *
     * ## Ordering
     * When considering NFTs, their order is governed by a combination of their numerical **token.Id** and **serialnumber** values, with **token.id** being the parent column.
     * A serialnumbers value governs its order within the given token.id
     *
     * In that regard, if a user acquired a set of NFTs in the order (2-2, 2-4 1-5, 1-1, 1-3, 3-3, 3-4), the following layouts illustrate the ordering expectations for ownership listing
     * 1. **All NFTs in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
     * 2. **All NFTs in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3, 1-1
     * 3. **NFTs above 1-1 in ASC order**: 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
     * 4. **NFTs below 3-3 in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4
     * 5. **NFTs between 1-3 and 3-3 inclusive in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3
     *
     * Note: The default order for this API is currently DESC
     *
     * ## Filtering
     * When filtering there are some restrictions enforced to ensure correctness and scalability.
     *
     * **The table below defines the restrictions and support for the NFT ownership endpoint**
     *
     * | Query Param   | Comparison Operator | Support | Description           | Example |
     * | ------------- | ------------------- | ------- | --------------------- | ------- |
     * | token.id      | eq                  | Y       | Single occurrence only. | ?token.id=X |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. | ?token.id=lte:X |
     * |               | gt(e)               | Y       | Single occurrence only. | ?token.id=gte:X |
     * | serialnumber  | eq                  | Y       | Single occurrence only. Requires the presence of a **token.id** query | ?serialnumber=Y |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **token.id** query | ?token.id=lte:X&serialnumber=lt:Y |
     * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **token.id** query | ?token.id=gte:X&serialnumber=gt:Y |
     * | spender.id    | eq                  | Y       | | ?spender.id=Z |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | | ?spender.id=lt:Z |
     * |               | gt(e)               | Y       | | ?spender.id=gt:Z |
     *
     * Note: When searching across a range for individual NFTs a **serialnumber** with an additional **token.id** query filter must be provided.
     * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
     */
    get: operations["listNftByAccountId"];
  };
  "/api/v1/accounts/{idOrAliasOrEvmAddress}/allowances/crypto": {
    /** Returns information for all crypto allowances for an account. */
    get: operations["listCryptoAllowancesByAccountId"];
  };
  "/api/v1/accounts/{idOrAliasOrEvmAddress}/allowances/tokens": {
    /**
     * Returns information for fungible token allowances for an account.
     *
     * ## Ordering
     * The order is governed by a combination of the spender id and the token id values, with spender id being the parent column.
     * The token id value governs its order within the given spender id.
     *
     * Note: The default order for this API is currently ASC
     *
     * ## Filtering
     * When filtering there are some restrictions enforced to ensure correctness and scalability.
     *
     * **The table below defines the restrictions and support for the token allowances endpoint**
     *
     * | Query Param   | Comparison Operator | Support | Description           | Example |
     * | ------------- | ------------------- | ------- | --------------------- | ------- |
     * | spender.id    | eq                  | Y       | Single occurrence only. | ?spender.id=X |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. | ?spender.id=lte:X |
     * |               | gt(e)               | Y       | Single occurrence only. | ?spender.id=gte:X |
     * | token.id      | eq                  | Y       | Single occurrence only. Requires the presence of a **spender.id** query | ?token.id=lt:Y |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **spender.id** query | ?spender.id=lte:X&token.id=lt:Y |
     * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **spender.id** query | ?spender.id=gte:X&token.id=gt:Y |
     *
     * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
     */
    get: operations["listTokenAllowancesByAccountId"];
  };
  "/api/v1/balances": {
    /** Returns a timestamped list of account balances on the network. This includes both HBAR and token balances for accounts. */
    get: operations["listAccountBalances"];
  };
  "/api/v1/blocks": {
    /** Returns a list of blocks on the network. */
    get: operations["listBlocks"];
  };
  "/api/v1/blocks/{hashOrNumber}": {
    /** Returns the block information by given hash or number. */
    get: operations["getByHashOrNumber"];
  };
  "/api/v1/contracts": {
    /** Returns a list of all contract entity items on the network. */
    get: operations["listContracts"];
  };
  "/api/v1/contracts/{contractIdOrAddress}": {
    /** Return the contract information given an id */
    get: operations["getContractById"];
  };
  "/api/v1/contracts/{contractIdOrAddress}/results": {
    /** Returns a list of all ContractResults for a contract's function executions. */
    get: operations["listContractResults"];
  };
  "/api/v1/contracts/{contractIdOrAddress}/results/{timestamp}": {
    /** Returns a single ContractResult for a contract's function executions at a specific timestamp. */
    get: operations["getContractResultByIdAndTimestamp"];
  };
  "/api/v1/contracts/results": {
    /** Returns a list of all ContractResults for all contract's function executions. */
    get: operations["listAllContractsResults"];
  };
  "/api/v1/contracts/results/{transactionIdOrHash}": {
    /** Returns a single ContractResult for a contract's function executions for a given transactionId or ethereum transaction hash. */
    get: operations["getContractResultByTransactionIdOrHash"];
  };
  "/api/v1/contracts/{contractIdOrAddress}/results/logs": {
    /**
     * Search the logs of a specific contract across multiple contract calls. Chained logs are not
     * included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
     * or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
     * and span a time range of at most seven days.
     *
     * ## Ordering
     * The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.
     *
     * Note: The default order for this API is currently DESC
     *
     * ## Filtering
     * When filtering there are some restrictions enforced to ensure correctness and scalability.
     *
     * **The table below defines the restrictions and support for the token allowances endpoint**
     *
     * | Query Param   | Comparison Operator | Support | Description           | Example |
     * | ------------- | ------------------- | ------- | --------------------- | ------- |
     * | index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
     * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
     * | timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
     * |               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y
     *
     *
     * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
     */
    get: operations["listContractLogs"];
  };
  "/api/v1/contracts/results/logs": {
    /**
     * Search the logs across many contracts with multiple contract calls. Chained logs are not
     * included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
     * or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
     * and span a time range of at most seven days.
     *
     * ## Ordering
     * The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.
     *
     * Note: The default order for this API is currently DESC
     *
     * ## Filtering
     * When filtering there are some restrictions enforced to ensure correctness and scalability.
     *
     * **The table below defines the restrictions and support for the token allowances endpoint**
     *
     * | Query Param   | Comparison Operator | Support | Description           | Example |
     * | ------------- | ------------------- | ------- | --------------------- | ------- |
     * | index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
     * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
     * | timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
     * |               | ne                  | N       | | |
     * |               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
     * |               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y
     *
     *
     * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
     */
    get: operations["listContractsLogs"];
  };
  "/api/v1/network/exchangerate": {
    /** Returns the network's exchange rate, current and next. */
    get: operations["getNetworkExchangeRate"];
  };
  "/api/v1/network/fees": {
    /** Returns the estimated gas in tinybars per each transaction type. Default order is ASC. Currently only `ContractCall`, `ContractCreate` and `EthereumTransaction` transaction types are supported. */
    get: operations["getNetworkFees"];
  };
  "/api/v1/network/nodes": {
    /** Returns the network's list of nodes used in consensus */
    get: operations["getNetworkNodes"];
  };
  "/api/v1/network/stake": {
    /** Returns the network's current stake information. */
    get: operations["getNetworkStake"];
  };
  "/api/v1/network/supply": {
    /** Returns the network's released supply of hbars */
    get: operations["getNetworkSupply"];
  };
  "/api/v1/schedules": {
    /** Lists schedules on the network that govern the execution logic of scheduled transactions. This includes executed and non executed schedules. */
    get: operations["listSchedules"];
  };
  "/api/v1/schedules/{scheduleId}": {
    /** Returns schedule information based on the given schedule id */
    get: operations["getScheduleById"];
  };
  "/api/v1/transactions": {
    /** Lists transactions on the network. This includes successful and unsuccessful transactions. */
    get: operations["listTransactions"];
  };
  "/api/v1/transactions/{transactionId}": {
    /** Returns transaction information based on the given transaction id */
    get: operations["getTransactionById"];
  };
  "/api/v1/transactions/{transactionId}/stateproof": {
    /** Returns the  contents of the address book file, signature files, and record file that can be used to validate the transaction occurred on the Hedera network given transaction id. */
    get: operations["getStateproofInfo"];
  };
  "/api/v1/topics/{topicId}/messages": {
    /** Returns the list of topic messages for the given topic id. */
    get: operations["listTopicMessagesById"];
  };
  "/api/v1/topics/{topicId}/messages/{sequenceNumber}": {
    /** Returns a single topic message the given topic id and sequence number. */
    get: operations["getTopicMessageByIdAndSequenceNumber"];
  };
  "/api/v1/topics/messages/{consensusTimestamp}": {
    /** Returns a topic message the given the consensusTimestamp. */
    get: operations["getTopicMessagesByConsensusTimestamp"];
  };
  "/api/v1/tokens": {
    /** Returns a list of tokens on the network. */
    get: operations["listTokens"];
  };
  "/api/v1/tokens/{tokenId}": {
    /** Returns token entity information given the id */
    get: operations["getTokenById"];
  };
  "/api/v1/tokens/{tokenId}/balances": {
    /** Returns a list of token balances given the id. This represents the Token supply distribution across the network */
    get: operations["listTokenBalancesById"];
  };
  "/api/v1/tokens/{tokenId}/nfts": {
    /** Returns a list of non-fungible tokens */
    get: operations["listNfts"];
  };
  "/api/v1/tokens/{tokenId}/nfts/{serialNumber}": {
    /** Returns information for a non-fungible token */
    get: operations["listNftBySerialnumber"];
  };
  "/api/v1/tokens/{tokenId}/nfts/{serialNumber}/transactions": {
    /** Returns a list of transactions for a given non-fungible token */
    get: operations["listNftTransactions"];
  };
}

export interface components {
  schemas: {
    /** @description Account alias in the format of 'shard.realm.alias', 'realm.alias', or 'alias'. 'alias' is the RFC4648 no-padding base32 encoded string of the account's alias. */
    AccountAlias: string;
    AccountsResponse: {
      accounts: components["schemas"]["Accounts"];
      links: components["schemas"]["Links"];
    };
    Allowance: {
      /**
       * Format: int64
       * @description The granted amount of the spender's allowance.
       * @example 100
       */
      amount_granted?: number;
      owner?: components["schemas"]["EntityId"];
      spender?: components["schemas"]["EntityId"];
      timestamp?: components["schemas"]["TimestampRange"];
    };
    BalancesResponse: {
      timestamp?: components["schemas"]["TimestampNullable"];
      balances?: components["schemas"]["AccountBalance"][];
      links?: components["schemas"]["Links"];
    };
    ContractResponse: components["schemas"]["Contract"] & {
      /**
       * Format: binary
       * @description The contract bytecode in hex
       * @example 0x01021a1fdc9b
       */
      bytecode?: string | null;
    };
    ContractsResponse: {
      contracts?: components["schemas"]["Contracts"];
      links?: components["schemas"]["Links"];
    };
    ContractResultResponse: {
      contracts?: components["schemas"]["ContractResultDetails"];
    };
    ContractResultsResponse: {
      contracts?: components["schemas"]["ContractResults"];
      links?: components["schemas"]["Links"];
    };
    ContractLogsResponse: {
      logs?: components["schemas"]["ContractLogs"];
    };
    CryptoAllowancesResponse: {
      allowances?: components["schemas"]["CryptoAllowances"];
      links?: components["schemas"]["Links"];
    };
    NetworkExchangeRateSetResponse: {
      current_rate?: components["schemas"]["ExchangeRate"];
      next_rate?: components["schemas"]["ExchangeRate"];
      timestamp?: components["schemas"]["Timestamp"];
    };
    NetworkFeesResponse: {
      fees?: components["schemas"]["NetworkFees"];
      timestamp?: components["schemas"]["Timestamp"];
    };
    NetworkNodesResponse: {
      nodes: components["schemas"]["NetworkNodes"];
      links: components["schemas"]["Links"];
    };
    NetworkStakeResponse: {
      network_stake?: components["schemas"]["NetworkStake"];
    };
    NetworkSupplyResponse: {
      /**
       * @description The network's released supply of hbars in tinybars
       * @example 3999999999999999949
       */
      released_supply?: string;
      timestamp?: components["schemas"]["Timestamp"] & unknown;
      /**
       * @description The network's total supply of hbars in tinybars
       * @example 5000000000000000000
       */
      total_supply?: string;
    };
    SchedulesResponse: {
      schedules?: components["schemas"]["Schedules"];
      links?: components["schemas"]["Links"];
    };
    BlocksResponse: {
      schedules?: components["schemas"]["Blocks"];
      links?: components["schemas"]["Links"];
    };
    /**
     * @example {
     *   "record_file": "YzNkOTg3Yzg3NDI5NGViOTViMmRmOWZkMzZiMDY1NjYyMzMxNTc2OWFmMmVmMzQ0YzM1ODY4NzgwMTAyYjVjMA==",
     *   "address_books": [
     *     "MjljY2IxNGNjNWY2NWM1MmZlYjc0MjkyYjAxZDUyZmRjZjJkZTY0NWQzOTRiNTM3MDQ2ODBkYjZkMTMyZWM2Yw=="
     *   ],
     *   "signature_files": {
     *     "0.0.3": "MWFmYzZlNWVjNGJiZTg0ZWJjNTVkMGViNDViMjE2Mzg2ZTQ2NjUzZTYyYmM1NjE2YThmZGJjNzQ1ZWIyMTQxNQ==",
     *     "0.0.4": "ZDI4ZDIwMGJiYTdkNDhmNTA3ZTE0MGZhNjIyOGFiYTdmMjlmZjhiMmEzZjJhOGVlYjg1NzQyZGMwNTNjZWM3MQ==",
     *     "0.0.5": "MWY0YmU5OGE3NWE4N2NkNjQ5ZTNlMWE1ODI1OTI3NTgwNWM1Y2RmNjNmYjA0YjMzMTdlZmI1MTEwNzQ2NDVjNw==",
     *     "0.0.6": "NzNiZTVmMTZkNmY4NTQ4MjdiN2M4MTEzZmFlY2I1YzIwNGI5ZjFkNjhiMzdkMzczNTg4OTRkOWFiZmM5N2U4Mw==",
     *     "0.0.7": "NDJiZTVmMTZkNmY4NTQ4MjdiN2M4MTEzZmFlY2I1YzIwNGI5ZjFkNjhiMzdkMzczNTg4OTRkOWFiZmM5N2U4Mw=="
     *   }
     * }
     */
    StateProofResponseFull: {
      /** @description The network address book valid at the time of the transaction */
      address_books: string[];
      /**
       * Format: byte
       * @description The content of the record file the transaction belongs to
       */
      record_file: string;
      /** @description The nodes' signature files for the record file */
      signature_files: { [key: string]: string };
    };
    /**
     * @example {
     *   "address_books": [
     *     "MjljY2IxNGNjNWY2NWM1MmZlYjc0MjkyYjAxZDUyZmRjZjJkZTY0NWQzOTRiNTM3MDQ2ODBkYjZkMTMyZWM2Yw=="
     *   ],
     *   "record_file": {
     *     "head": "AAAABQAAAAAAAAAbAAAAAAAAAAE==",
     *     "start_running_hash_object": "9CLag6JRdB4AAAABWP+BGwAAADCTEm5j2O9qy33fqKR/F0sKXYqPPQCt92kA2koMvkg4h6uhnEX/H0iXWL4CxWCK+C8=",
     *     "end_running_hash_object": "9CLag6JRdB4AAAABWP+BGwAAADAkK6BKPFKbOX46Kul0OiAYR5x52X0cJLgPvmOjupycWgXRyItITx7HrfSjH5LpU6Q=",
     *     "hashes_before": [
     *       "RxKzucDUGgqBgR+CXXfAKgYuE/xhIaBlo+hmMKyxrm8nmSiaG3a9hlLGHh6+yXFm"
     *     ],
     *     "hashes_after": [
     *       "TOJuZz3EUX1RNdRJBfz7n+V9cYyEm//ER9h3s/y1d8nzs0VqYltJFE0dPangRC6c",
     *       "RiRHvjPQPqUXNlvDJ6lPiv40ZOPVV3VcWRH8GOKFf6Xv9jK0vUjR2qGfjI/IRZRy"
     *     ],
     *     "record_stream_object": "43CSm6VCnYsAAAABAAAA2gpgCBYqJAoQCLDqARCA3AsaBgjQ6f2WBhIQCLDqARCm5QsaBgjghf6WBjiR6EhCMDNd1b7xmTuNNiLcn2bdlAI=",
     *     "block_number": "AAECoA=="
     *   },
     *   "signature_files": {
     *     "0.0.3": "MWFmYzZlNWVjNGJiZTg0ZWJjNTVkMGViNDViMjE2Mzg2ZTQ2NjUzZTYyYmM1NjE2YThmZGJjNzQ1ZWIyMTQxNQ==",
     *     "0.0.4": "ZDI4ZDIwMGJiYTdkNDhmNTA3ZTE0MGZhNjIyOGFiYTdmMjlmZjhiMmEzZjJhOGVlYjg1NzQyZGMwNTNjZWM3MQ==",
     *     "0.0.5": "MWY0YmU5OGE3NWE4N2NkNjQ5ZTNlMWE1ODI1OTI3NTgwNWM1Y2RmNjNmYjA0YjMzMTdlZmI1MTEwNzQ2NDVjNw==",
     *     "0.0.6": "NzNiZTVmMTZkNmY4NTQ4MjdiN2M4MTEzZmFlY2I1YzIwNGI5ZjFkNjhiMzdkMzczNTg4OTRkOWFiZmM5N2U4Mw==",
     *     "0.0.7": "NDJiZTVmMTZkNmY4NTQ4MjdiN2M4MTEzZmFlY2I1YzIwNGI5ZjFkNjhiMzdkMzczNTg4OTRkOWFiZmM5N2U4Mw=="
     *   },
     *   "version": 6
     * }
     */
    StateProofResponseCompact: {
      /** @description The network address book valid at the time of the transaction */
      address_books: string[];
      /** @description The record file the transaction belongs to, in compact format */
      record_file: {
        /**
         * Format: byte
         * @description The record file head
         */
        head: string;
        /**
         * Format: byte
         * @description The start running hash object
         */
        start_running_hash_object: string;
        /**
         * Format: byte
         * @description THe end running hash object
         */
        end_running_hash_object: string;
        /** @description The hashes of the transactions before the transaction in query, in consensus timestamp ascending order */
        hashes_before: string[];
        /** @description The hashes of the transactions after the transaction in query, in consensus timestamp ascending order */
        hashes_after: string[];
        /**
         * Format: byte
         * @description The record stream object of the transaction in query
         */
        record_stream_object: string;
        /**
         * Format: byte
         * @description The block number, in base64 encoding. Only present if version is 6
         */
        block_number: string | null;
      };
      /** @description The nodes' signature files for the record file */
      signature_files: { [key: string]: string };
      /** @description The record file format version, either 5 or 6 */
      version: number;
    };
    TokenAllowancesResponse: {
      allowances?: components["schemas"]["TokenAllowances"];
      links?: components["schemas"]["Links"];
    };
    TokenBalancesResponse: {
      timestamp?: components["schemas"]["TimestampNullable"];
      balances?: components["schemas"]["TokenDistribution"];
      links?: components["schemas"]["Links"];
    };
    TokensResponse: {
      tokens?: components["schemas"]["Tokens"];
      links?: components["schemas"]["Links"];
    };
    TopicMessagesResponse: {
      messages?: components["schemas"]["TopicMessages"];
      links?: components["schemas"]["Links"];
    };
    TransactionByIdResponse: {
      transactions?: components["schemas"]["TransactionDetails"];
    };
    TransactionsResponse: {
      transactions?: components["schemas"]["Transactions"];
      links?: components["schemas"]["Links"];
    };
    /**
     * @example {
     *   "account": "0.0.8",
     *   "alias": "HIQQEXWKW53RKN4W6XXC4Q232SYNZ3SZANVZZSUME5B5PRGXL663UAQA",
     *   "auto_renew_period": null,
     *   "balance": {
     *     "timestamp": "0.000002345",
     *     "balance": 80,
     *     "tokens": [
     *       {
     *         "token_id": "0.0.200001",
     *         "balance": 8
     *       }
     *     ]
     *   },
     *   "decline_reward": false,
     *   "deleted": false,
     *   "ethereum_nonce": 10,
     *   "evm_address": "0xac384c53f03855fa1b3616052f8ba32c6c2a2fec",
     *   "expiry_timestamp": null,
     *   "key": null,
     *   "max_automatic_token_associations": 200,
     *   "memo": "entity memo",
     *   "receiver_sig_required": false,
     *   "staked_account_id": null,
     *   "staked_node_id": 3,
     *   "stake_period_start": 2000
     * }
     */
    AccountInfo: {
      account: components["schemas"]["EntityId"];
      alias: components["schemas"]["Alias"];
      /** Format: int64 */
      auto_renew_period: number | null;
      balance: components["schemas"]["Balance"];
      /** @description Whether the account declines receiving a staking reward */
      decline_reward: boolean;
      deleted: boolean | null;
      /** Format: int64 */
      ethereum_nonce: number | null;
      evm_address: components["schemas"]["EvmAddressNullable"];
      expiry_timestamp: components["schemas"]["TimestampNullable"];
      key: components["schemas"]["Key"];
      /** Format: int32 */
      max_automatic_token_associations: number | null;
      memo: string | null;
      receiver_sig_required: boolean | null;
      staked_account_id: components["schemas"]["EntityId"] & unknown;
      /**
       * Format: int64
       * @description The id of the node to which this account is staking
       */
      staked_node_id: number | null;
      stake_period_start: components["schemas"]["TimestampNullable"] & unknown;
    };
    Accounts: components["schemas"]["AccountInfo"][];
    /**
     * @example {
     *   "account": "0.15.10",
     *   "balance": 80,
     *   "tokens": [
     *     {
     *       "token_id": "0.0.200001",
     *       "balance": 8
     *     }
     *   ]
     * }
     */
    AccountBalance: {
      account: components["schemas"]["EntityId"];
      balance: number;
      tokens: components["schemas"]["TokenBalance"][];
    };
    AccountBalanceTransactions: components["schemas"]["AccountInfo"] & {
      transactions: components["schemas"]["Transactions"];
      links: components["schemas"]["Links"];
    };
    /**
     * @description RFC4648 no-padding base32 encoded account alias
     * @example HIQQEXWKW53RKN4W6XXC4Q232SYNZ3SZANVZZSUME5B5PRGXL663UAQA
     */
    Alias: string | null;
    /**
     * @example {
     *   "timestamp": "0.000002345",
     *   "balance": 80,
     *   "tokens": [
     *     {
     *       "token_id": "0.0.200001",
     *       "balance": 8
     *     }
     *   ]
     * }
     */
    Balance: {
      timestamp: components["schemas"]["TimestampNullable"];
      balance: number | null;
      tokens: {
        token_id?: components["schemas"]["EntityId"];
        balance?: number;
      }[];
    } | null;
    /**
     * Format: binary
     * @example 0x549358c4c2e573e02410ef7b5a5ffa5f36dd7398
     */
    Bloom: { [key: string]: unknown } | null;
    ChunkInfo: {
      initial_transaction_id?: components["schemas"]["TransactionId"];
      /** @example 1 */
      number?: number;
      /** @example 2 */
      total?: number;
    } | null;
    Contract: {
      admin_key?: components["schemas"]["Key"];
      auto_renew_account?: components["schemas"]["EntityId"];
      /** @example null */
      auto_renew_period?: number | null;
      contract_id?: components["schemas"]["EntityId"];
      created_timestamp?: components["schemas"]["TimestampNullable"];
      /** @example false */
      deleted?: boolean;
      evm_address?: components["schemas"]["EvmAddress"];
      expiration_timestamp?: components["schemas"]["TimestampNullable"];
      file_id?: components["schemas"]["EntityId"];
      /** Format: int32 */
      max_automatic_token_associations?: number | null;
      /** @example contract memo */
      memo?: string;
      obtainer_id?: components["schemas"]["EntityId"];
      permanent_removal?: boolean | null;
      proxy_account_id?: components["schemas"]["EntityId"];
      timestamp?: components["schemas"]["TimestampRange"];
    };
    Contracts: components["schemas"]["Contract"][];
    ContractLog: components["schemas"]["ContractResultLog"] & {
      root_contract_id?: components["schemas"]["EntityId"] & unknown;
      timestamp?: components["schemas"]["Timestamp"];
    };
    /**
     * @description A list of hex encoded topics associated with this log event
     * @example [
     *   "0xf4757a49b326036464bec6fe419a4ae38c8a02ce3e68bf0809674f6aab8ad300"
     * ]
     */
    ContractLogTopics: string[];
    ContractResult: {
      /**
       * Format: int64
       * @description The number of tinybars sent to the function
       * @example 10
       */
      amount?: number | null;
      bloom?: components["schemas"]["Bloom"] & unknown;
      /**
       * @description The hex encoded result returned by the function
       * @example 0x2b048531b38d2882e86044bc972e940ee0a01938
       */
      call_result?: string | null;
      contract_id?: components["schemas"]["EntityId"];
      /** @description The network's released supply of hbars in tinybars */
      created_contract_ids?: components["schemas"]["EntityId"][] | null;
      /**
       * @description The message when an error occurs during smart contract execution
       * @example Out of gas
       */
      error_message?: string | null;
      from?: components["schemas"]["EvmAddress"];
      /**
       * @description The hex encoded parameters passed to the function
       * @example 0xbb9f02dc6f0e3289f57a1f33b71c73aa8548ab8b
       */
      function_parameters?: string | null;
      /**
       * Format: int64
       * @description The maximum units of gas allowed for contract execution
       * @example 100000
       */
      gas_limit?: number;
      /**
       * Format: int64
       * @description The units of gas used to execute contract
       * @example 1000
       */
      gas_used?: number | null;
      /**
       * @description A hex encoded 32 byte hash and it is only populated for Ethereum transaction case
       * @example 0xfebbaa29c513d124a6377246ea3506ad917d740c21a88f61a1c55ba338fc2bb1
       */
      hash?: string | null;
      /**
       * @description The result of the transaction
       * @example SUCCESS
       */
      result?: string;
      /**
       * @description The status of the transaction, 0x1 for a SUCCESS transaction and 0x0 for all else
       * @example 1
       */
      status?: string;
      timestamp?: components["schemas"]["Timestamp"];
      to?: components["schemas"]["EvmAddressNullable"];
    };
    ContractResultDetails: components["schemas"]["ContractResult"] & {
      /**
       * @description The hex encoded access_list of the wrapped ethereum transaction
       * @example 0xabcd
       */
      access_list?: string | null;
      /**
       * Format: int64
       * @description The total amount of gas used in the block
       * @example 2000
       */
      block_gas_used?: number | null;
      /**
       * @description The hex encoded block (record file chain) hash
       * @example 0x6ceecd8bb224da491
       */
      block_hash?: string | null;
      /**
       * Format: int64
       * @description The block number. Since Hedera does not have the native concept of blocks, this counts the number of record files seen since the mirror node's configured start date. This can vary between mirror nodes that use different start dates.
       * @example 10
       */
      block_number?: number | null;
      /**
       * @description The hex encoded chain_id of the wrapped ethereum transaction
       * @example 0x0127
       */
      chain_id?: string | null;
      /**
       * @description The hex encoded initcode of a failed contract create transaction
       * @example 0x856739
       */
      failed_initcode?: string;
      /**
       * @description The hex encoded gas_price of the wrapped ethereum transaction
       * @example 0x4a817c800
       */
      gas_price?: string | null;
      /**
       * @description The hex encoded transaction hash
       * @example 0x3531396130303866616264653464
       */
      hash?: string;
      logs?: components["schemas"]["ContractResultLogs"];
      /**
       * @description The hex encoded max_fee_per_gas of the wrapped ethereum transaction
       * @example 0x5
       */
      max_fee_per_gas?: string | null;
      /**
       * @description The hex encoded max_priority_fee_per_gas of the wrapped ethereum transaction
       * @example 0x100
       */
      max_priority_fee_per_gas?: string | null;
      /**
       * Format: int64
       * @description The nonce of the wrapped ethereum transaction
       * @example 1
       */
      nonce?: number | null;
      /**
       * @description The hex encoded signature_r of the wrapped ethereum transaction
       * @example 0xd693b532a80fed6392b428604171fb32fdbf953728a3a7ecc7d4062b1652c043
       */
      r?: string | null;
      /**
       * @description The hex encoded signature_s of the wrapped ethereum transaction
       * @example 0x24e9c602ac800b983b035700a14b23f78a253ab762deab5dc27e3555a750b355
       */
      s?: string | null;
      state_changes?: components["schemas"]["ContractResultStateChanges"];
      /**
       * Format: int64
       * @description The position of the transaction in the block
       * @example 1
       */
      transaction_index?: number | null;
      /**
       * @description The type of the wrapped ethereum transaction, 0 (Pre-Eip1559) or 2 (Post-Eip1559)
       * @example 2
       */
      type?: number | null;
      /**
       * @description The recovery_id of the wrapped ethereum transaction
       * @example 1
       */
      v?: number | null;
    };
    ContractResultLog: {
      /**
       * @description The hex encoded EVM address of the contract
       * @example 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef
       */
      address?: string;
      bloom?: components["schemas"]["Bloom"] & unknown;
      contract_id?: components["schemas"]["EntityId"];
      /**
       * @description The hex encoded data of the contract log
       * @example 0x00000000000000000000000000000000000000000000000000000000000000fa
       */
      data?: string | null;
      /**
       * @description The index of the contract log in the chain of logs for an execution
       * @example 0
       */
      index?: number;
      topics?: components["schemas"]["ContractLogTopics"];
    };
    ContractResultLogs: components["schemas"]["ContractResultLog"][];
    ContractResultStateChange: {
      address?: components["schemas"]["EvmAddress"];
      contract_id?: components["schemas"]["EntityId"];
      /**
       * Format: binary
       * @description The hex encoded storage slot changed.
       * @example 0x00000000000000000000000000000000000000000000000000000000000000fa
       */
      slot?: string;
      /**
       * Format: binary
       * @description The hex encoded value read from the storage slot.
       * @example 0x97c1fc0a6ed5551bc831571325e9bdb365d06803100dc20648640ba24ce69750
       */
      value_read?: string;
      /**
       * Format: binary
       * @description The hex encoded value written to the slot. `null` implies no value written.
       * @example 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925
       */
      value_written?: string | null;
    };
    ContractResultStateChanges: components["schemas"]["ContractResultStateChange"][];
    ContractResults: components["schemas"]["ContractResult"][];
    ContractLogs: components["schemas"]["ContractLog"][];
    CustomFees: {
      created_timestamp?: components["schemas"]["Timestamp"];
      fixed_fees?: components["schemas"]["FixedFee"][];
      fractional_fees?: components["schemas"]["FractionalFee"][];
      royalty_fees?: components["schemas"]["RoyaltyFee"][];
    };
    CryptoAllowance: components["schemas"]["Allowance"] & {
      /** @description The granted amount of the spender's allowance in tinybars. */
      amount_granted?: unknown;
    };
    CryptoAllowances: components["schemas"]["CryptoAllowance"][];
    /**
     * @description Network entity ID in the format of `shard.realm.num`
     * @example 0.1.2
     */
    EntityId: { [key: string]: unknown } | null;
    EntityIdQuery: string;
    Error: {
      _status?: {
        messages?: {
          message?: string;
        }[];
      };
    };
    /** @description A hex encoded hedera transaction hash. */
    HederaHash: string;
    /** @description A hex encoded ethereum transaction hash. */
    EthereumHash: string;
    /**
     * Format: int64
     * @description A positive number.
     */
    PositiveNumber: number;
    /**
     * Format: binary
     * @description A network entity encoded as an EVM address in hex.
     * @example 0000000000000000000000000000000000001f41
     */
    EvmAddress: { [key: string]: unknown };
    /**
     * Format: binary
     * @description A network entity encoded as an EVM address in hex.
     * @example 0x0000000000000000000000000000000000001f41
     */
    EvmAddressWithShardRealm: string;
    /**
     * Format: binary
     * @description A network entity encoded as an EVM address in hex.
     * @example 0x0000000000000000000000000000000000001f41
     */
    EvmAddressNullable: string | null;
    ExchangeRate: {
      /** @example 596987 */
      cent_equivalent?: number;
      /** @example 1649689200 */
      expiration_time?: number;
      /** @example 30000 */
      hbar_equivalent?: number;
    };
    FixedFee: {
      /** @example 100 */
      amount?: number;
      collector_account_id?: components["schemas"]["EntityId"];
      denominating_token_id?: components["schemas"]["EntityId"];
    };
    FractionalFee: {
      amount?: {
        /** @example 12 */
        numerator?: number;
        /** @example 29 */
        denominator?: number;
      };
      collector_account_id?: components["schemas"]["EntityId"];
      denominating_token_id?: components["schemas"]["EntityId"];
      /** @example 120 */
      maximum?: number | null;
      /** @example 30 */
      minimum?: number;
      /** @example true */
      net_of_transfers?: boolean;
    };
    RoyaltyFee: {
      amount?: {
        /** @example 15 */
        numerator?: number;
        /** @example 37 */
        denominator?: number;
      };
      collector_account_id?: components["schemas"]["EntityId"];
      fallback_fee?: {
        /** @example 100 */
        amount?: number;
        denominating_token_id?: components["schemas"]["EntityId"];
      };
    };
    Key: {
      /**
       * @example ProtobufEncoded
       * @enum {string}
       */
      _type?: "ECDSA_SECP256K1" | "ED25519" | "ProtobufEncoded";
      /** @example 10101 */
      key?: string;
    } | null;
    Links: {
      /** @example /api/v1/transactions?timestamp=lt:1657598275.517984411 */
      next?: string | null;
    };
    /**
     * @example {
     *   "description": "address book 1",
     *   "file_id": "0.0.102",
     *   "max_stake": 50000,
     *   "memo": "0.0.4",
     *   "min_stake": 1000,
     *   "node_account_id": "0.0.4",
     *   "node_cert_hash": "0x01d173753810c0aae794ba72d5443c292e9ff962b01046220dd99f5816422696e0569c977e2f169e1e5688afc8f4aa16",
     *   "node_id": 1,
     *   "public_key": "0x4a5ad514f0957fa170a676210c9bdbddf3bc9519702cf915fa6767a40463b96f",
     *   "reward_rate_start": 1000000,
     *   "service_endpoints": [
     *     {
     *       "ip_address_v4": "128.0.0.6",
     *       "port": 50216
     *     }
     *   ],
     *   "stake": 20000,
     *   "stake_not_rewarded": 19900,
     *   "stake_rewarded": 100,
     *   "staking_period": {
     *     "from": "1655164800.000000000",
     *     "to": "1655251200.000000000"
     *   },
     *   "timestamp": {
     *     "from": "187654.000123457",
     *     "to": null
     *   }
     * }
     */
    NetworkNode: {
      /** @description a memo associated with the address book */
      description: string | null;
      file_id: components["schemas"]["EntityId"];
      /**
       * Format: int64
       * @description The maximum stake (rewarded or not rewarded) this node can have as consensus weight
       */
      max_stake: number | null;
      /** @description memo */
      memo: string | null;
      /**
       * Format: int64
       * @description The minimum stake (rewarded or not rewarded) this node must reach before having non-zero consensus weight
       */
      min_stake: number | null;
      node_account_id: components["schemas"]["EntityId"];
      /** @description An identifier for the node */
      node_id: number;
      /** @description hex encoded hash of the node’s TLS certificate */
      node_cert_hash: string | null;
      /** @description hex encoded X509 RSA public key used to verify stream file signature */
      public_key: string | null;
      /**
       * Format: int64
       * @description The total tinybars earned by this node in the last staking period
       */
      reward_rate_start: number | null;
      service_endpoints: components["schemas"]["ServiceEndpoints"];
      /**
       * Format: int64
       * @description The node consensus weight at the beginning of the staking period
       */
      stake: number | null;
      /**
       * Format: int64
       * @description The sum (balance + stakedToMe) for all accounts staked to this node with declineReward=true at the
       * beginning of the staking period
       */
      stake_not_rewarded: number | null;
      /**
       * Format: int64
       * @description The sum (balance + staked) for all accounts staked to the node that are not declining rewards at the
       * beginning of the staking period
       */
      stake_rewarded: number | null;
      staking_period: components["schemas"]["TimestampRange"] &
        (unknown | null);
      timestamp: components["schemas"]["TimestampRange"];
    };
    NetworkNodes: components["schemas"]["NetworkNode"][];
    NetworkFee: {
      /**
       * Format: int64
       * @description gas cost in tinybars
       */
      gas?: number;
      /** @description type of the transaction */
      transaction_type?: string;
    };
    NetworkFees: components["schemas"]["NetworkFee"][];
    /**
     * @example {
     *   "max_staking_reward_rate_per_hbar": "17808,",
     *   "node_reward_fee_fraction": "1.0,",
     *   "stake_total": "35000000000000000,",
     *   "staking_period": {
     *     "from": "1655164800.000000000",
     *     "to": "1655251200.000000000"
     *   },
     *   "staking_period_duration": "1440,",
     *   "staking_periods_stored": "365,",
     *   "staking_reward_fee_fraction": "1.0,",
     *   "staking_reward_rate": "100000000000,",
     *   "staking_start_threshold": 25000000000000000
     * }
     */
    NetworkStake: {
      /**
       * Format: int64
       * @description The maximum reward rate, in tinybars per whole hbar, that any account can receive in a day
       */
      max_staking_reward_rate_per_hbar: number;
      /**
       * Format: float
       * @description The fraction between zero and one of the network and service fees paid to the node reward account 0.0.801
       */
      node_reward_fee_fraction: number;
      /**
       * Format: int64
       * @description The total amount staked to the network in tinybars the start of the current staking period
       */
      stake_total: number;
      staking_period: components["schemas"]["TimestampRange"] & unknown;
      /**
       * Format: int64
       * @description The number of minutes in a staking period
       */
      staking_period_duration: number;
      /**
       * Format: int64
       * @description The number of staking periods for which the reward is stored for each node
       */
      staking_periods_stored: number;
      /**
       * Format: float
       * @description The fraction between zero and one of the network and service fees paid to the staking reward account 0.0.800
       */
      staking_reward_fee_fraction: number;
      /**
       * Format: int64
       * @description The total number of tinybars to be distributed as staking rewards each period
       */
      staking_reward_rate: number;
      /**
       * Format: int64
       * @description The minimum balance of staking reward account 0.0.800 required to active rewards
       */
      staking_start_threshold: number;
    };
    /**
     * @example {
     *   "account_id": "0.1.2",
     *   "created_timestamp": "1234567890.000000001",
     *   "delegating_spender": "0.0.400",
     *   "deleted": false,
     *   "metadata": "VGhpcyBpcyBhIHRlc3QgTkZU",
     *   "modified_timestamp": "1610682445.003266001",
     *   "serial_number": 124,
     *   "spender_id": "0.0.500",
     *   "token_id": "0.0.222"
     * }
     */
    Nft: {
      account_id?: components["schemas"]["EntityId"];
      created_timestamp?: components["schemas"]["TimestampNullable"];
      delegating_spender?: components["schemas"]["EntityId"];
      /** @description whether the nft or the token it belongs to has been deleted */
      deleted?: boolean;
      /**
       * Format: byte
       * @description base64 encoded binary data
       */
      metadata?: string;
      modified_timestamp?: components["schemas"]["TimestampNullable"];
      serial_number?: number;
      spender?: components["schemas"]["EntityId"];
      token_id?: components["schemas"]["EntityId"];
    };
    Nfts: {
      nfts?: components["schemas"]["Nft"][];
      links?: components["schemas"]["Links"];
    };
    /**
     * @example {
     *   "consensus_timestamp": "1618591023.997420021",
     *   "id": "0.0.19789-1618591023-997420021",
     *   "is_approval": false,
     *   "receiver_account_id": "0.0.11",
     *   "sender_account_id": "0.0.10",
     *   "type": "CRYPTOTRANSFER",
     *   "token_id": "0.0.1000"
     * }
     */
    NftTransactionTransfer: {
      consensus_timestamp?: components["schemas"]["Timestamp"];
      is_approval?: boolean;
      nonce?: number;
      transaction_id?: string;
      receiver_account_id?: components["schemas"]["EntityId"];
      sender_account_id?: components["schemas"]["EntityId"];
      type?: components["schemas"]["TransactionTypes"];
      token_id?: components["schemas"]["EntityId"];
    };
    /**
     * @example {
     *   "count": 3,
     *   "gas_used": 300000,
     *   "hapi_version": "0.11.0",
     *   "hash": "0x3c08bbbee74d287b1dcd3f0ca6d1d2cb92c90883c4acf9747de9f3f3162ad25b999fc7e86699f60f2a3fb3ed9a646c6b",
     *   "logs_bloom": "0x00000020002000001000000000000000000000000000000000000000000010000000000004000000000000000000000000108000000000000000000080000000000004000000000000000000000000880000000000000000000101000000000000000000000000000000000000008000000000000400000080000000000001000000000000000000000000000000000000000000002000000000100000100000200000040000100000001000000000000000000000000000000001001000004000000000000000000001000000000000000000100000000000100000000000000000000000000000000000000000000000080000100800000000000000120080",
     *   "name": "2022-05-03T06_46_26.060890949Z.rcd",
     *   "number": 77,
     *   "previous_hash": "0xf7d6481f659c866c35391ee230c374f163642ebf13a5e604e04a95a9ca48a298dc2dfa10f51bcbaab8ae23bc6d662a0b",
     *   "size": 8192,
     *   "timestamp": {
     *     "from": "1651560386.060890949",
     *     "to": "1651560386.661997287"
     *   }
     * }
     */
    Block: {
      count?: number;
      /** Format: int64 */
      gas_used?: number | null;
      hapi_version?: string;
      hash?: string;
      /** @description A hex encoded 256-byte array with 0x prefix */
      logs_bloom?: string | null;
      name?: string;
      number?: number;
      previous_hash?: string;
      size?: number | null;
      timestamp?: {
        from?: components["schemas"]["TimestampRange"];
        to?: components["schemas"]["TimestampRange"];
      };
    };
    Blocks: components["schemas"]["Block"][];
    NftTransactionHistory: {
      transactions?: components["schemas"]["NftTransactionTransfer"][];
      links?: components["schemas"]["Links"];
    };
    Schedule: {
      admin_key?: components["schemas"]["Key"];
      consensus_timestamp?: components["schemas"]["Timestamp"];
      creator_account_id?: components["schemas"]["EntityId"];
      /** @example false */
      deleted?: boolean;
      executed_timestamp?: components["schemas"]["TimestampNullable"];
      expiration_time?: components["schemas"]["TimestampNullable"];
      /** @example created on 02/10/2021 */
      memo?: string;
      payer_account_id?: components["schemas"]["EntityId"];
      schedule_id?: components["schemas"]["EntityId"];
      signatures?: components["schemas"]["ScheduleSignature"][];
      /**
       * Format: byte
       * @example Kd6tvu8=
       */
      transaction_body?: string;
      wait_for_expiry?: boolean;
    };
    Schedules: components["schemas"]["Schedule"][];
    ScheduleSignature: {
      consensus_timestmap?: components["schemas"]["Timestamp"];
      /**
       * Format: byte
       * @example AAEBAwuqAwzB
       */
      public_key_prefix?: string;
      /**
       * Format: byte
       * @example 3q2+7wABAQMLqgMMwQ==
       */
      signature?: string;
      /**
       * @example ED25519
       * @enum {string}
       */
      type?:
        | "CONTRACT"
        | "ED25519"
        | "RSA_3072"
        | "ECDSA_384"
        | "ECDSA_SECP256K1"
        | "UNKNOWN";
    };
    /**
     * @example {
     *   "ip_address_v4": "127.0.0.1",
     *   "port": 50211
     * }
     */
    ServiceEndpoint: {
      ip_address_v4: string;
      port: number;
    };
    ServiceEndpoints: components["schemas"]["ServiceEndpoint"][];
    /** @example 1586567700.453054000 */
    Timestamp: { [key: string]: unknown };
    /** @example 1586567700.453054000 */
    TimestampNullable: { [key: string]: unknown } | null;
    /** @description A timestamp range an entity is valid for */
    TimestampRange: {
      from?: components["schemas"]["Timestamp"] & unknown;
      to?: components["schemas"]["TimestampNullable"] & unknown;
    };
    /**
     * @example {
     *   "token_id": "0.0.1",
     *   "symbol": "FIRSTMOVERLPDJH",
     *   "admin_key": null,
     *   "type": "FUNGIBLE_COMMON"
     * }
     */
    Token: {
      token_id: components["schemas"]["EntityId"];
      symbol: string;
      admin_key: components["schemas"]["Key"];
      type: string;
    };
    TokenAllowance: components["schemas"]["Allowance"] & {
      token_id?: components["schemas"]["EntityId"];
    };
    TokenAllowances: components["schemas"]["TokenAllowance"][];
    /**
     * @example {
     *   "token_id": "0.0.200001",
     *   "balance": 8
     * }
     */
    TokenBalance: {
      token_id: components["schemas"]["EntityId"];
      balance: number;
    };
    /**
     * @example [
     *   {
     *     "account": "0.15.2",
     *     "balance": 1000
     *   }
     * ]
     */
    TokenDistribution: {
      account: components["schemas"]["EntityId"];
      balance: number;
    }[];
    TokenInfo: {
      admin_key?: components["schemas"]["Key"];
      auto_renew_account?: components["schemas"]["EntityId"];
      /** @example null */
      auto_renew_period?: unknown | null;
      created_timestamp?: components["schemas"]["Timestamp"];
      /** @example 1000 */
      decimals?: string;
      /** @example true */
      deleted?: boolean | null;
      expiry_timestamp?: components["schemas"]["TimestampNullable"];
      fee_schedule_key?: components["schemas"]["Key"];
      /** @example false */
      freeze_default?: boolean;
      freeze_key?: components["schemas"]["Key"];
      /** @example 1000000 */
      initial_supply?: string;
      kyc_key?: components["schemas"]["Key"];
      /** @example 9223372036854775807 */
      max_supply?: string;
      modified_timestamp?: components["schemas"]["Timestamp"];
      /** @example Token name */
      name?: string;
      /** @example token memo */
      memo?: string;
      pause_key?: components["schemas"]["Key"];
      /**
       * @example UNPAUSED
       * @enum {string}
       */
      pause_status?: "NOT_APPLICABLE" | "PAUSED" | "UNPAUSED";
      supply_key?: components["schemas"]["Key"];
      /**
       * @example INFINITE
       * @enum {string}
       */
      supply_type?: "FINITE" | "INFINITE";
      /** @example ORIGINALRDKSE */
      symbol?: string;
      token_id?: components["schemas"]["EntityId"];
      /** @example 1000000 */
      total_supply?: string;
      treasury_account_id?: components["schemas"]["EntityId"];
      /**
       * @example FUNGIBLE_COMMON
       * @enum {string}
       */
      type?: "FUNGIBLE_COMMON" | "NON_FUNGIBLE_UNIQUE";
      wipe_key?: components["schemas"]["Key"];
      custom_fees?: components["schemas"]["CustomFees"];
    };
    LogTopicQueryParam: string[];
    /** @enum {string} */
    TransactionTypes:
      | "CONSENSUSCREATETOPIC"
      | "CONSENSUSDELETETOPIC"
      | "CONSENSUSSUBMITMESSAGE"
      | "CONSENSUSUPDATETOPIC"
      | "CONTRACTCALL"
      | "CONTRACTCREATEINSTANCE"
      | "CONTRACTDELETEINSTANCE"
      | "CONTRACTUPDATEINSTANCE"
      | "CRYPTOADDLIVEHASH"
      | "CRYPTOAPPROVEALLOWANCE"
      | "CRYPTOCREATEACCOUNT"
      | "CRYPTODELETE"
      | "CRYPTODELETEALLOWANCE"
      | "CRYPTODELETELIVEHASH"
      | "CRYPTOTRANSFER"
      | "CRYPTOUPDATEACCOUNT"
      | "ETHEREUMTRANSACTION"
      | "FILEAPPEND"
      | "FILECREATE"
      | "FILEDELETE"
      | "FILEUPDATE"
      | "FREEZE"
      | "NODESTAKEUPDATE"
      | "SCHEDULECREATE"
      | "SCHEDULEDELETE"
      | "SCHEDULESIGN"
      | "SYSTEMDELETE"
      | "SYSTEMUNDELETE"
      | "TOKENASSOCIATE"
      | "TOKENBURN"
      | "TOKENCREATION"
      | "TOKENDELETION"
      | "TOKENDISSOCIATE"
      | "TOKENFEESCHEDULEUPDATE"
      | "TOKENFREEZE"
      | "TOKENGRANTKYC"
      | "TOKENMINT"
      | "TOKENPAUSE"
      | "TOKENREVOKEKYC"
      | "TOKENUNFREEZE"
      | "TOKENUNPAUSE"
      | "TOKENUPDATE"
      | "TOKENWIPE"
      | "UNCHECKEDSUBMIT"
      | "UNKNOWN"
      | "UTILPRNG";
    Tokens: components["schemas"]["Token"][];
    /**
     * @example {
     *   "chunk_info": {
     *     "initial_transaction_id": "0.0.10-1234567890-000000321",
     *     "nonce": 3,
     *     "number": 1,
     *     "total": 2,
     *     "scheduled": true
     *   },
     *   "consensus_timestamp": "1234567890.000000001",
     *   "message": "bWVzc2FnZQ==",
     *   "payer_account_id": "0.0.10",
     *   "running_hash": "cnVubmluZ19oYXNo",
     *   "running_hash_version": 2,
     *   "sequence_number": 1,
     *   "topic_id": "0.0.7"
     * }
     */
    TopicMessage: {
      chunk_info?: components["schemas"]["ChunkInfo"];
      consensus_timestamp: components["schemas"]["Timestamp"];
      message: string;
      payer_account_id: components["schemas"]["EntityId"];
      /** Format: byte */
      running_hash: string;
      running_hash_version: number;
      sequence_number: number;
      topic_id: components["schemas"]["EntityId"];
    };
    TopicMessages: components["schemas"]["TopicMessage"][];
    /**
     * @example {
     *   "bytes": null,
     *   "charged_tx_fee": 7,
     *   "consensus_timestamp": "1234567890.000000007",
     *   "entity_id": "0.0.2281979",
     *   "max_fee": 33,
     *   "memo_base64": null,
     *   "name": "CRYPTOTRANSFER",
     *   "node": "0.0.3",
     *   "nonce": 0,
     *   "parent_consensus_timestamp": "1234567890.000000007",
     *   "result": "SUCCESS",
     *   "scheduled": false,
     *   "transaction_hash": "vigzKe2J7fv4ktHBbNTSzQmKq7Lzdq1/lJMmHT+a2KgvdhAuadlvS4eKeqKjIRmW",
     *   "transaction_id": "0.0.8-1234567890-000000006",
     *   "token_transfers": [
     *     {
     *       "token_id": "0.0.90000",
     *       "account": "0.0.9",
     *       "amount": 1200,
     *       "is_approval": false
     *     },
     *     {
     *       "token_id": "0.0.90000",
     *       "account": "0.0.8",
     *       "amount": -1200,
     *       "is_approval": false
     *     }
     *   ],
     *   "transfers": [
     *     {
     *       "account": "0.0.3",
     *       "amount": 2,
     *       "is_approval": false
     *     },
     *     {
     *       "account": "0.0.8",
     *       "amount": -3,
     *       "is_approval": false
     *     },
     *     {
     *       "account": "0.0.98",
     *       "amount": 1,
     *       "is_approval": false
     *     }
     *   ],
     *   "valid_duration_seconds": 11,
     *   "valid_start_timestamp": "1234567890.000000006"
     * }
     */
    Transaction: {
      /** Format: byte */
      bytes?: string | null;
      charged_tx_fee?: number;
      consensus_timestamp?: components["schemas"]["Timestamp"];
      entity_id?: components["schemas"]["EntityId"];
      max_fee?: string;
      /** Format: byte */
      memo_base64?: string | null;
      name?: components["schemas"]["TransactionTypes"];
      node?: components["schemas"]["EntityId"];
      nonce?: number;
      parent_consensus_timestamp?: components["schemas"]["TimestampNullable"];
      result?: string;
      scheduled?: boolean;
      token_transfers?: {
        token_id: components["schemas"]["EntityId"];
        account: components["schemas"]["EntityId"];
        amount: number;
        is_approval?: boolean;
      }[];
      /** Format: byte */
      transaction_hash?: string;
      transaction_id?: string;
      transfers?: {
        account: components["schemas"]["EntityId"];
        amount: number;
        is_approval?: boolean;
      }[];
      valid_duration_seconds?: string;
      valid_start_timestamp?: components["schemas"]["Timestamp"];
    };
    /**
     * @example {
     *   "assessed_custom_fees": [
     *     {
     *       "amount": 100,
     *       "collector_account_id": "0.0.10",
     *       "effective_payer_account_ids": [
     *         "0.0.8",
     *         "0.0.72"
     *       ],
     *       "token_id": "0.0.90001"
     *     }
     *   ],
     *   "bytes": null,
     *   "charged_tx_fee": 7,
     *   "consensus_timestamp": "1234567890.000000007",
     *   "entity_id": "0.0.2281979",
     *   "max_fee": 33,
     *   "memo_base64": null,
     *   "name": "CRYPTOTRANSFER",
     *   "nft_transfers": [
     *     {
     *       "is_approval": true,
     *       "receiver_account_id": "0.0.121",
     *       "sender_account_id": "0.0.122",
     *       "serial_number": 1,
     *       "token_id": "0.0.123"
     *     },
     *     {
     *       "is_approval": true,
     *       "receiver_account_id": "0.0.321",
     *       "sender_account_id": "0.0.422",
     *       "serial_number": 2,
     *       "token_id": "0.0.123"
     *     }
     *   ],
     *   "node": "0.0.3",
     *   "nonce": 0,
     *   "parent_consensus_timestamp": "1234567890.000000007",
     *   "result": "SUCCESS",
     *   "scheduled": false,
     *   "transaction_hash": "vigzKe2J7fv4ktHBbNTSzQmKq7Lzdq1/lJMmHT+a2KgvdhAuadlvS4eKeqKjIRmW",
     *   "transaction_id": "0.0.8-1234567890-000000006",
     *   "token_transfers": [
     *     {
     *       "token_id": "0.0.90000",
     *       "account": "0.0.9",
     *       "amount": 1200,
     *       "is_approval": true
     *     },
     *     {
     *       "token_id": "0.0.90000",
     *       "account": "0.0.8",
     *       "amount": -1200,
     *       "is_approval": true
     *     }
     *   ],
     *   "transfers": [
     *     {
     *       "account": "0.0.3",
     *       "amount": 2,
     *       "is_approval": true
     *     },
     *     {
     *       "account": "0.0.8",
     *       "amount": -3,
     *       "is_approval": true
     *     },
     *     {
     *       "account": "0.0.98",
     *       "amount": 1,
     *       "is_approval": true
     *     }
     *   ],
     *   "valid_duration_seconds": 11,
     *   "valid_start_timestamp": "1234567890.000000006"
     * }
     */
    TransactionDetail: components["schemas"]["Transaction"] & {
      assessed_custom_fees?: {
        amount?: number;
        collector_account_id?: components["schemas"]["EntityId"];
        effective_payer_account_ids?: components["schemas"]["EntityId"][];
        token_id?: components["schemas"]["EntityId"];
      }[];
      nft_transfers?: {
        is_approval?: boolean;
        receiver_account_id?: components["schemas"]["EntityId"];
        sender_account_id?: components["schemas"]["EntityId"];
        serial_number: number;
        token_id: components["schemas"]["EntityId"];
      }[];
    };
    TransactionDetails: components["schemas"]["TransactionDetail"][];
    TransactionId: {
      account_id?: components["schemas"]["EntityId"];
      /** @example 0 */
      nonce?: number | null;
      /** @example false */
      scheduled?: boolean | null;
      transaction_valid_start?: components["schemas"]["Timestamp"];
    };
    /** @description A transaction id in string format. */
    TransactionIdStr: string;
    Transactions: components["schemas"]["Transaction"][];
  };
  responses: {
    /** Not Found */
    NotFoundError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Topic Not Found */
    TopicNotFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Transaction Not Found */
    TransactionNotFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Invalid parameter */
    InvalidParameterError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** Service Unavailable */
    ServiceUnavailableError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: {
    /** @description Account alias or account id or evm address */
    accountIdOrAliasOrEvmAddressPathParam:
      | components["schemas"]["AccountAlias"]
      | components["schemas"]["EntityId"]
      | components["schemas"]["EvmAddress"]
      | components["schemas"]["EvmAddressWithShardRealm"];
    /** @description The optional balance value to compare against */
    accountBalanceQueryParam: string;
    /** @description The ID of the account to return information for */
    accountIdQueryParam: components["schemas"]["EntityIdQuery"];
    /**
     * @description The account's public key to compare against
     * @example 3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be
     */
    accountPublicKeyQueryParam: string;
    /**
     * @description Whether to include balance information or not
     * @example true
     */
    balanceQueryParam: boolean;
    /** @description The ID of the smart contract */
    contractIdQueryParam:
      | components["schemas"]["EntityIdQuery"]
      | components["schemas"]["EvmAddressWithShardRealm"];
    /** @description The ID or hex encoded EVM address associated with this contract. */
    contractIdPathParam:
      | components["schemas"]["EntityId"]
      | components["schemas"]["EvmAddressWithShardRealm"];
    /** @description Accepts both eth and hedera hash format or block number */
    hashOrNumberPathParam:
      | components["schemas"]["HederaHash"]
      | components["schemas"]["EthereumHash"]
      | components["schemas"]["PositiveNumber"];
    /** @description Entity id */
    entityIdPathParam: components["schemas"]["EntityId"];
    /** @description The ID of the file entity */
    fileIdQueryParam: components["schemas"]["EntityIdQuery"];
    /** @description Schedule id */
    scheduleIdPathParam: components["schemas"]["EntityId"];
    /** @description Token id */
    tokenIdPathParam: components["schemas"]["EntityId"];
    /** @description Topic id */
    topicIdPathParam: components["schemas"]["EntityId"];
    /** @description Account ID or EVM address executing the contract */
    fromQueryParam:
      | components["schemas"]["EntityId"]
      | components["schemas"]["EvmAddress"];
    /** @description Contract log index */
    logIndexQueryParam: string;
    /**
     * @description The maximum number of items to return
     * @example 2
     */
    limitQueryParam: number;
    /** @description The block's number */
    blockNumberQueryParam: string;
    /** @description The ID of the node */
    nodeIdQueryParam: string;
    /**
     * @description Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. If not specified, all transactions with specified payer account ID and valid start timestamp match.
     * @example 0
     */
    nonceQueryParam: number;
    /**
     * @description Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. Default is 0 when not specified.
     * @example 1
     */
    nonceQueryParamWithDefault: number;
    /**
     * @description The order in which items are listed
     * @example desc
     */
    orderQueryParam: "asc" | "desc";
    /**
     * @description The order in which items are listed
     * @example asc
     */
    orderQueryParamDesc: "asc" | "desc";
    /**
     * @description The public key to compare against
     * @example 3c3d546321ff6f63d701d2ec5c277095874e19f4a235bee1e6bb19258bf362be
     */
    publicKeyQueryParam: string;
    /** @description Filter transactions by the scheduled flag. If true, return information for the scheduled transaction. If false, return information for the non-scheduled transaction. If not present, return information for all transactions matching transactionId. */
    scheduledQueryParam: boolean;
    /** @description Filter transactions by the scheduled flag. If true, return information for the scheduled transaction. If false, return information for the non-scheduled transaction. */
    scheduledQueryParamWithDefault: boolean;
    /** @description The ID of the schedule to return information for */
    scheduleIdQueryParam: components["schemas"]["EntityIdQuery"];
    /**
     * @description The nft serial number
     * @example 1
     */
    serialNumberPathParam: number;
    /** @description The nft serial number (64 bit type). Requires a tokenId value also be populated. */
    serialNumberQueryParam: string;
    /** @description The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
    timestampQueryParam: string[];
    /**
     * @description The timestamp at which the associated transaction reached consensus
     * @example 1234567890.0000007
     */
    timestampPathParam: string;
    tokenInfoTimestampQueryParam: string;
    /** @description The first topic associated with a contract log. Requires a timestamp range also be populated. */
    logTopic0QueryParam: components["schemas"]["LogTopicQueryParam"];
    /** @description The second topic associated with a contract log. Requires a timestamp range also be populated. */
    logTopic1QueryParam: components["schemas"]["LogTopicQueryParam"];
    /** @description The third topic associated with a contract log. Requires a timestamp range also be populated. */
    logTopic2QueryParam: components["schemas"]["LogTopicQueryParam"];
    /** @description The fourth topic associated with a contract log. Requires a timestamp range also be populated. */
    logTopic3QueryParam: components["schemas"]["LogTopicQueryParam"];
    /** @description The ID of the spender to return information for */
    spenderIdQueryParam: components["schemas"]["EntityIdQuery"];
    /** @example cryptotransfer */
    transactionTypeQueryParam: components["schemas"]["TransactionTypes"];
    /**
     * @description Transaction id
     * @example 0.0.10-1234567890-000000000
     */
    transactionIdPathParam: string;
    /** @description The ID of the token to return information for */
    tokenIdQueryParam: components["schemas"]["EntityIdQuery"];
    /**
     * @example [
     *   "ALL",
     *   "FUNGIBLE_COMMON",
     *   "NON_FUNGIBLE_UNIQUE"
     * ]
     */
    tokenTypeQueryParam: string[];
    /** @description The block's number */
    contractsBlockNumberQueryParam: string;
    /** @description The block's hash */
    blockHashQueryParam: string;
    /**
     * @description The transaction index in the block
     * @example 1
     */
    transactionIndexQueryParam: number;
    /**
     * @description Whether to include child transactions or not
     * @example true
     */
    internalQueryParam: boolean;
    /** @description Transaction Id or a 32 byte hash with optional 0x prefix */
    transactionIdOrEthHashPathParam:
      | components["schemas"]["EthereumHash"]
      | components["schemas"]["TransactionIdStr"];
  };
}

export interface operations {
  /** Returns a list of all account entity items on the network. */
  listAccounts: {
    parameters: {
      query: {
        /** The optional balance value to compare against */
        "account.balance"?: components["parameters"]["accountBalanceQueryParam"];
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The account's public key to compare against */
        "account.publickey"?: components["parameters"]["accountPublicKeyQueryParam"];
        /** Whether to include balance information or not */
        balance?: components["parameters"]["balanceQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["AccountsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Return the account transactions and balance information given an account alias, an account id, or an evm address */
  getAccountByIdOrAliasOrEvmAddress: {
    parameters: {
      path: {
        /** Account alias or account id or evm address */
        idOrAliasOrEvmAddress: components["parameters"]["accountIdOrAliasOrEvmAddressPathParam"];
      };
      query: {
        transactiontype?: components["parameters"]["transactionTypeQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["AccountBalanceTransactions"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Returns information for all non-fungible tokens for an account.
   *
   * ## Ordering
   * When considering NFTs, their order is governed by a combination of their numerical **token.Id** and **serialnumber** values, with **token.id** being the parent column.
   * A serialnumbers value governs its order within the given token.id
   *
   * In that regard, if a user acquired a set of NFTs in the order (2-2, 2-4 1-5, 1-1, 1-3, 3-3, 3-4), the following layouts illustrate the ordering expectations for ownership listing
   * 1. **All NFTs in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
   * 2. **All NFTs in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3, 1-1
   * 3. **NFTs above 1-1 in ASC order**: 1-3, 1-5, 2-2, 2-4, 3-3, 3-4
   * 4. **NFTs below 3-3 in ASC order**: 1-1, 1-3, 1-5, 2-2, 2-4
   * 5. **NFTs between 1-3 and 3-3 inclusive in DESC order**: 3-4, 3-3, 2-4, 2-2, 1-5, 1-3
   *
   * Note: The default order for this API is currently DESC
   *
   * ## Filtering
   * When filtering there are some restrictions enforced to ensure correctness and scalability.
   *
   * **The table below defines the restrictions and support for the NFT ownership endpoint**
   *
   * | Query Param   | Comparison Operator | Support | Description           | Example |
   * | ------------- | ------------------- | ------- | --------------------- | ------- |
   * | token.id      | eq                  | Y       | Single occurrence only. | ?token.id=X |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. | ?token.id=lte:X |
   * |               | gt(e)               | Y       | Single occurrence only. | ?token.id=gte:X |
   * | serialnumber  | eq                  | Y       | Single occurrence only. Requires the presence of a **token.id** query | ?serialnumber=Y |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **token.id** query | ?token.id=lte:X&serialnumber=lt:Y |
   * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **token.id** query | ?token.id=gte:X&serialnumber=gt:Y |
   * | spender.id    | eq                  | Y       | | ?spender.id=Z |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | | ?spender.id=lt:Z |
   * |               | gt(e)               | Y       | | ?spender.id=gt:Z |
   *
   * Note: When searching across a range for individual NFTs a **serialnumber** with an additional **token.id** query filter must be provided.
   * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
   */
  listNftByAccountId: {
    parameters: {
      path: {
        /** Account alias or account id or evm address */
        idOrAliasOrEvmAddress: components["parameters"]["accountIdOrAliasOrEvmAddressPathParam"];
      };
      query: {
        /** The ID of the token to return information for */
        "token.id"?: components["parameters"]["tokenIdQueryParam"];
        /** The nft serial number (64 bit type). Requires a tokenId value also be populated. */
        serialnumber?: components["parameters"]["serialNumberQueryParam"];
        /** The ID of the spender to return information for */
        "spender.id"?: components["parameters"]["spenderIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Nfts"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns information for all crypto allowances for an account. */
  listCryptoAllowancesByAccountId: {
    parameters: {
      path: {
        /** Account alias or account id or evm address */
        idOrAliasOrEvmAddress: components["parameters"]["accountIdOrAliasOrEvmAddressPathParam"];
      };
      query: {
        /** The ID of the spender to return information for */
        "spender.id"?: components["parameters"]["spenderIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["CryptoAllowancesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Returns information for fungible token allowances for an account.
   *
   * ## Ordering
   * The order is governed by a combination of the spender id and the token id values, with spender id being the parent column.
   * The token id value governs its order within the given spender id.
   *
   * Note: The default order for this API is currently ASC
   *
   * ## Filtering
   * When filtering there are some restrictions enforced to ensure correctness and scalability.
   *
   * **The table below defines the restrictions and support for the token allowances endpoint**
   *
   * | Query Param   | Comparison Operator | Support | Description           | Example |
   * | ------------- | ------------------- | ------- | --------------------- | ------- |
   * | spender.id    | eq                  | Y       | Single occurrence only. | ?spender.id=X |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. | ?spender.id=lte:X |
   * |               | gt(e)               | Y       | Single occurrence only. | ?spender.id=gte:X |
   * | token.id      | eq                  | Y       | Single occurrence only. Requires the presence of a **spender.id** query | ?token.id=lt:Y |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of an **lte** or **eq** **spender.id** query | ?spender.id=lte:X&token.id=lt:Y |
   * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of an **gte** or **eq** **spender.id** query | ?spender.id=gte:X&token.id=gt:Y |
   *
   * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
   */
  listTokenAllowancesByAccountId: {
    parameters: {
      path: {
        /** Account alias or account id or evm address */
        idOrAliasOrEvmAddress: components["parameters"]["accountIdOrAliasOrEvmAddressPathParam"];
      };
      query: {
        /** The ID of the spender to return information for */
        "spender.id"?: components["parameters"]["spenderIdQueryParam"];
        /** The ID of the token to return information for */
        "token.id"?: components["parameters"]["tokenIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokenAllowancesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a timestamped list of account balances on the network. This includes both HBAR and token balances for accounts. */
  listAccountBalances: {
    parameters: {
      query: {
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The optional balance value to compare against */
        "account.balance"?: components["parameters"]["accountBalanceQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The account's public key to compare against */
        "account.publickey"?: components["parameters"]["accountPublicKeyQueryParam"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["BalancesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns a list of blocks on the network. */
  listBlocks: {
    parameters: {
      query: {
        /** The block's number */
        "block.number"?: components["parameters"]["blockNumberQueryParam"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["BlocksResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns the block information by given hash or number. */
  getByHashOrNumber: {
    parameters: {
      path: {
        /** Accepts both eth and hedera hash format or block number */
        hashOrNumber: components["parameters"]["hashOrNumberPathParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Block"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of all contract entity items on the network. */
  listContracts: {
    parameters: {
      query: {
        /** The ID of the smart contract */
        "contract.id"?: components["parameters"]["contractIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Return the contract information given an id */
  getContractById: {
    parameters: {
      path: {
        /** The ID or hex encoded EVM address associated with this contract. */
        contractIdOrAddress: components["parameters"]["contractIdPathParam"];
      };
      query: {
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of all ContractResults for a contract's function executions. */
  listContractResults: {
    parameters: {
      path: {
        /** The ID or hex encoded EVM address associated with this contract. */
        contractIdOrAddress: components["parameters"]["contractIdPathParam"];
      };
      query: {
        /** Account ID or EVM address executing the contract */
        from?: components["parameters"]["fromQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The block's number */
        "block.number"?: components["parameters"]["contractsBlockNumberQueryParam"];
        /** The block's hash */
        "block.hash"?: components["parameters"]["blockHashQueryParam"];
        /** The transaction index in the block */
        "transaction.index"?: components["parameters"]["transactionIndexQueryParam"];
        /** Whether to include child transactions or not */
        internal?: components["parameters"]["internalQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResultsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns a single ContractResult for a contract's function executions at a specific timestamp. */
  getContractResultByIdAndTimestamp: {
    parameters: {
      path: {
        /** The ID or hex encoded EVM address associated with this contract. */
        contractIdOrAddress: components["parameters"]["contractIdPathParam"];
        /** The timestamp at which the associated transaction reached consensus */
        timestamp: components["parameters"]["timestampPathParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResultResponse"];
        };
      };
      /** Partial Content */
      206: {
        content: {
          "application/json": components["schemas"]["ContractResultResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of all ContractResults for all contract's function executions. */
  listAllContractsResults: {
    parameters: {
      query: {
        /** Account ID or EVM address executing the contract */
        from?: components["parameters"]["fromQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The block's number */
        "block.number"?: components["parameters"]["contractsBlockNumberQueryParam"];
        /** The block's hash */
        "block.hash"?: components["parameters"]["blockHashQueryParam"];
        /** The transaction index in the block */
        "transaction.index"?: components["parameters"]["transactionIndexQueryParam"];
        /** Whether to include child transactions or not */
        internal?: components["parameters"]["internalQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResultsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns a single ContractResult for a contract's function executions for a given transactionId or ethereum transaction hash. */
  getContractResultByTransactionIdOrHash: {
    parameters: {
      path: {
        /** Transaction Id or a 32 byte hash with optional 0x prefix */
        transactionIdOrHash: components["parameters"]["transactionIdOrEthHashPathParam"];
      };
      query: {
        /** Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. Default is 0 when not specified. */
        nonce?: components["parameters"]["nonceQueryParamWithDefault"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractResultResponse"];
        };
      };
      /** Partial Content */
      206: {
        content: {
          "application/json": components["schemas"]["ContractResultResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /**
   * Search the logs of a specific contract across multiple contract calls. Chained logs are not
   * included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
   * or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
   * and span a time range of at most seven days.
   *
   * ## Ordering
   * The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.
   *
   * Note: The default order for this API is currently DESC
   *
   * ## Filtering
   * When filtering there are some restrictions enforced to ensure correctness and scalability.
   *
   * **The table below defines the restrictions and support for the token allowances endpoint**
   *
   * | Query Param   | Comparison Operator | Support | Description           | Example |
   * | ------------- | ------------------- | ------- | --------------------- | ------- |
   * | index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
   * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
   * | timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
   * |               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y
   *
   *
   * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
   */
  listContractLogs: {
    parameters: {
      path: {
        /** The ID or hex encoded EVM address associated with this contract. */
        contractIdOrAddress: components["parameters"]["contractIdPathParam"];
      };
      query: {
        /** Contract log index */
        index?: components["parameters"]["logIndexQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The first topic associated with a contract log. Requires a timestamp range also be populated. */
        topic0?: components["parameters"]["logTopic0QueryParam"];
        /** The second topic associated with a contract log. Requires a timestamp range also be populated. */
        topic1?: components["parameters"]["logTopic1QueryParam"];
        /** The third topic associated with a contract log. Requires a timestamp range also be populated. */
        topic2?: components["parameters"]["logTopic2QueryParam"];
        /** The fourth topic associated with a contract log. Requires a timestamp range also be populated. */
        topic3?: components["parameters"]["logTopic3QueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractLogsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /**
   * Search the logs across many contracts with multiple contract calls. Chained logs are not
   * included but can be found by calling `/api/v1/contracts/{contractId}/results/{timestamp}`
   * or `/api/v1/contracts/results/{transactionId}`. When searching by topic a timestamp parameter must be supplied
   * and span a time range of at most seven days.
   *
   * ## Ordering
   * The order is governed by the combination of timestamp and index values. If the index param is omitted, the order is determined by the timestamp only.
   *
   * Note: The default order for this API is currently DESC
   *
   * ## Filtering
   * When filtering there are some restrictions enforced to ensure correctness and scalability.
   *
   * **The table below defines the restrictions and support for the token allowances endpoint**
   *
   * | Query Param   | Comparison Operator | Support | Description           | Example |
   * | ------------- | ------------------- | ------- | --------------------- | ------- |
   * | index         | eq                  | Y       | Single occurrence only. Requires the presence of timestamp | ?index=X |
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=lte:X |
   * |               | gt(e)               | Y       | Single occurrence only. Requires the presence of timestamp | ?index=gte:X |
   * | timestamp     | eq                  | Y       | Single occurrence only. | ?timestamp=Y
   * |               | ne                  | N       | | |
   * |               | lt(e)               | Y       | Single occurrence only. Optional second timestamp **gt(e)** | ?timestamp=lte:Y
   * |               | gt(e)               | Y       | Single occurrence only. Optional second timestamp **lt(e)** | ?timestamp=gte:Y
   *
   *
   * Both filters must be a single occurrence of **gt(e)** or **lt(e)** which provide a lower and or upper boundary for search.
   */
  listContractsLogs: {
    parameters: {
      query: {
        /** Contract log index */
        index?: components["parameters"]["logIndexQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The first topic associated with a contract log. Requires a timestamp range also be populated. */
        topic0?: components["parameters"]["logTopic0QueryParam"];
        /** The second topic associated with a contract log. Requires a timestamp range also be populated. */
        topic1?: components["parameters"]["logTopic1QueryParam"];
        /** The third topic associated with a contract log. Requires a timestamp range also be populated. */
        topic2?: components["parameters"]["logTopic2QueryParam"];
        /** The fourth topic associated with a contract log. Requires a timestamp range also be populated. */
        topic3?: components["parameters"]["logTopic3QueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["ContractLogsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns the network's exchange rate, current and next. */
  getNetworkExchangeRate: {
    parameters: {
      query: {
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NetworkExchangeRateSetResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
      500: components["responses"]["ServiceUnavailableError"];
    };
  };
  /** Returns the estimated gas in tinybars per each transaction type. Default order is ASC. Currently only `ContractCall`, `ContractCreate` and `EthereumTransaction` transaction types are supported. */
  getNetworkFees: {
    parameters: {
      query: {
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NetworkFeesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
      500: components["responses"]["ServiceUnavailableError"];
    };
  };
  /** Returns the network's list of nodes used in consensus */
  getNetworkNodes: {
    parameters: {
      query: {
        /** The ID of the file entity */
        "file.id"?: components["parameters"]["fileIdQueryParam"];
        /** The ID of the node */
        "node.id"?: components["parameters"]["nodeIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NetworkNodesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns the network's current stake information. */
  getNetworkStake: {
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NetworkStakeResponse"];
        };
      };
      404: components["responses"]["NotFoundError"];
      500: components["responses"]["ServiceUnavailableError"];
    };
  };
  /** Returns the network's released supply of hbars */
  getNetworkSupply: {
    parameters: {
      query: {
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NetworkSupplyResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Lists schedules on the network that govern the execution logic of scheduled transactions. This includes executed and non executed schedules. */
  listSchedules: {
    parameters: {
      query: {
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
        /** The ID of the schedule to return information for */
        "schedule.id"?: components["parameters"]["scheduleIdQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["SchedulesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns schedule information based on the given schedule id */
  getScheduleById: {
    parameters: {
      path: {
        /** Schedule id */
        scheduleId: components["parameters"]["scheduleIdPathParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Schedule"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Lists transactions on the network. This includes successful and unsuccessful transactions. */
  listTransactions: {
    parameters: {
      query: {
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        transactiontype?: components["parameters"]["transactionTypeQueryParam"];
        /** The transaction success type. */
        result?: "success" | "fail";
        /** The transaction account balance modification type. */
        type?: "credit" | "debit";
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TransactionsResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns transaction information based on the given transaction id */
  getTransactionById: {
    parameters: {
      path: {
        /** Transaction id */
        transactionId: components["parameters"]["transactionIdPathParam"];
      };
      query: {
        /** Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. If not specified, all transactions with specified payer account ID and valid start timestamp match. */
        nonce?: components["parameters"]["nonceQueryParam"];
        /** Filter transactions by the scheduled flag. If true, return information for the scheduled transaction. If false, return information for the non-scheduled transaction. If not present, return information for all transactions matching transactionId. */
        scheduled?: components["parameters"]["scheduledQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TransactionByIdResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns the  contents of the address book file, signature files, and record file that can be used to validate the transaction occurred on the Hedera network given transaction id. */
  getStateproofInfo: {
    parameters: {
      path: {
        /** Transaction id */
        transactionId: components["parameters"]["transactionIdPathParam"];
      };
      query: {
        /** Filter the query result by the nonce of the transaction. A zero nonce represents user submitted transactions while a non-zero nonce is generated by main nodes. The filter honors the last value. Default is 0 when not specified. */
        nonce?: components["parameters"]["nonceQueryParamWithDefault"];
        /** Filter transactions by the scheduled flag. If true, return information for the scheduled transaction. If false, return information for the non-scheduled transaction. */
        scheduled?: components["parameters"]["scheduledQueryParamWithDefault"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json":
            | components["schemas"]["StateProofResponseCompact"]
            | components["schemas"]["StateProofResponseFull"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["TransactionNotFound"];
      502: components["responses"]["ServiceUnavailableError"];
    };
  };
  /** Returns the list of topic messages for the given topic id. */
  listTopicMessagesById: {
    parameters: {
      path: {
        /** Topic id */
        topicId: components["parameters"]["topicIdPathParam"];
      };
      query: {
        sequencenumber?: number;
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        encoding?: string;
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TopicMessagesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["TopicNotFound"];
    };
  };
  /** Returns a single topic message the given topic id and sequence number. */
  getTopicMessageByIdAndSequenceNumber: {
    parameters: {
      path: {
        /** Topic id */
        topicId: components["parameters"]["topicIdPathParam"];
        /** Topic message sequence number */
        sequencenumber: number;
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TopicMessagesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a topic message the given the consensusTimestamp. */
  getTopicMessagesByConsensusTimestamp: {
    parameters: {
      path: {
        /** The timestamp at which the associated transaction reached consensus */
        timestamp: components["parameters"]["timestampPathParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TopicMessage"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of tokens on the network. */
  listTokens: {
    parameters: {
      query: {
        /** The public key to compare against */
        publickey?: components["parameters"]["publicKeyQueryParam"];
        /** The ID of the token to return information for */
        "token.id"?: components["parameters"]["tokenIdQueryParam"];
        type?: components["parameters"]["tokenTypeQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokensResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns token entity information given the id */
  getTokenById: {
    parameters: {
      path: {
        /** Token id */
        tokenId: components["parameters"]["tokenIdPathParam"];
      };
      query: {
        timestamp?: components["parameters"]["tokenInfoTimestampQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokenInfo"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of token balances given the id. This represents the Token supply distribution across the network */
  listTokenBalancesById: {
    parameters: {
      path: {
        /** Token id */
        tokenId: components["parameters"]["tokenIdPathParam"];
      };
      query: {
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The optional balance value to compare against */
        "account.balance"?: components["parameters"]["accountBalanceQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParam"];
        /** The account's public key to compare against */
        "account.publickey"?: components["parameters"]["accountPublicKeyQueryParam"];
        /** The consensus timestamp in seconds.nanoseconds format with an optional comparison operator */
        timestamp?: components["parameters"]["timestampQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["TokenBalancesResponse"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns a list of non-fungible tokens */
  listNfts: {
    parameters: {
      path: {
        /** Token id */
        tokenId: components["parameters"]["tokenIdPathParam"];
      };
      query: {
        /** The ID of the account to return information for */
        "account.id"?: components["parameters"]["accountIdQueryParam"];
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Nfts"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
  /** Returns information for a non-fungible token */
  listNftBySerialnumber: {
    parameters: {
      path: {
        /** Token id */
        tokenId: components["parameters"]["tokenIdPathParam"];
        /** The nft serial number */
        serialNumber: components["parameters"]["serialNumberPathParam"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["Nft"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
      404: components["responses"]["NotFoundError"];
    };
  };
  /** Returns a list of transactions for a given non-fungible token */
  listNftTransactions: {
    parameters: {
      path: {
        /** Token id */
        tokenId: components["parameters"]["tokenIdPathParam"];
        /** The nft serial number */
        serialNumber: components["parameters"]["serialNumberPathParam"];
      };
      query: {
        /** The maximum number of items to return */
        limit?: components["parameters"]["limitQueryParam"];
        /** The order in which items are listed */
        order?: components["parameters"]["orderQueryParamDesc"];
      };
    };
    responses: {
      /** OK */
      200: {
        content: {
          "application/json": components["schemas"]["NftTransactionHistory"];
        };
      };
      /** Partial Content */
      206: {
        content: {
          "application/json": components["schemas"]["NftTransactionHistory"];
        };
      };
      400: components["responses"]["InvalidParameterError"];
    };
  };
}

export interface external {}
